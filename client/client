#!/usr/bin/perl
#
# This file is part of the NSM framework
#
# Copyright (C) 2010-2011, Edward Fjellsk√•l <edwardfjellskaal@gmail.com>
#                          Eduardo Urias    <windkaiser@gmail.com>
#                          Ian Firns        <firnsy@securixlive.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License Version 2 as
# published by the Free Software Foundation.  You may not use, modify or
# distribute this program under any other version of the GNU General
# Public License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

use lib '../lib';

use warnings;
use strict;
use v5.10;

#
# PERL INCLUDES
#
use Carp;
use Data::Dumper;
use POE;
use POE::Component::Client::TCP;
use POE::Filter::Line;
use POE::Wheel::ReadWrite;

#
# NSMF INCLUDES
#
use NSMF::Common::JSON;
use NSMF::Common::Logger;
use NSMF::Common::Util;
use NSMF::Client;

#
# GLOBALS
#
our $VERSION = '0.1';

my $nsmf    = NSMF::Client->new();
my $config  = $nsmf->config();
my $proto   = $nsmf->proto();
my $logger  = NSMF::Common::Logger->new();

my ($self) = @_;

my $host = $config->host();
my $port = $config->port();

my $module_active = 'core';
my $modules = [];
my $commands = {};


if ( ! defined_args($host, $port) ) {
    die('Either host or port have NOT been defined.');
}

POE::Component::Client::TCP->new(
    Alias         => 'client',
    RemoteAddress => $host,
    RemotePort    => $port,
    Filter        => "POE::Filter::Line",
    Connected => sub {
        my ($kernel, $heap) = @_[KERNEL, HEAP];
        $logger->info("[+] Connected to server ($host:$port) ...");

        $heap->{name}   = undef; #$config->name();
        $heap->{secret} = undef; #$config->secret();

        $kernel->yield('login');
    },
    ConnectError => sub {
        $logger->warn("Could not connect to server ($host:$port) ...");
    },
    ServerInput => sub {
        my ($kernel, $response) = @_[KERNEL, ARG0];

        $kernel->yield(dispatcher => $response);
    },
    ServerError => sub {
        my ($kernel, $heap) = @_[KERNEL, HEAP];
        $logger->warn("Lost connection to server...");
        $logger->info("Going Down.");
        exit;
    },
    ObjectStates => [
        $proto => $proto->states(),
    ],
    InlineStates => {
        'login' => \&login,
        'prompt' => \&prompt,
        'load_session' => \&load_session,
    }
);

$logger->info('Client Initialized ...');

sub init
{
#    $commands
#        "modules_available" => {
#          "help" => "Returns the available modules.",
#          "exec" => \&get_modules_available,
#        },

}


sub login
{
    my ($kernel, $heap) = @_[KERNEL, HEAP];

    if( ! defined($heap->{name}) ) {
        $heap->{name} = input_get('Username: ');
    }

    if( ! defined($heap->{secret}) ) {
        $heap->{secret} = input_get('Password: ');
    }

    $kernel->yield('authenticate');
}

sub load_session
{
    my ($kernel, $heap) = @_[KERNEL, HEAP];

    # clear existing known commands
    $modules = [];
    $commands = {};

    # start the query process
    $kernel->yield('get', {
        type => 'core',
        data => 'modules_available'
    }, sub {
        my ($s, $k, $h, $json) = @_;

        $modules = $json->{result} // [];

        foreach my $m ( @{ $modules } ) {
            $commands->{$m} = [];

            $kernel->yield('get', {
                type => $m,
                data => 'commands_available'
            }, sub {
                my ($s, $k, $h, $json) = @_;

                $commands->{$m} = $json->{result} // [];
            });
        }
    });

    # build up
    $heap->{console} = POE::Wheel::ReadWrite->new(
        InputHandle => \*STDIN,
        OutputHandle => \*STDOUT,
        InputEvent => "prompt"
    );

    # show we are ready to recieve user prompt
    prompt_print();
}




sub prompt
{
    my ($kernel, $heap, $data) = @_[KERNEL, HEAP, ARG0];

    my @action = split(/[ ]/, $data);

    if( @action ) {
        given( $data )
        {
            when(/^search\sevent\s(.*)/) {
                my $sql = prompt_process_event_search($1);
                $kernel->yield('get', {
                    type => "core",
                    data => {
                      "search_event" => $sql
                    },
                }, sub {
                    my ($s, $k, $h, $json) = @_;

                    my $result = $json->{result} // [];

                    # TODO post process result with client aware components

                    say( "Total records: " . @{ $result });
                });
            }
            when(/^search\ssession\s(.*)/) {
                my $sql = prompt_process_session_search($1);
                $kernel->yield('get', {
                    type => "core",
                    data => {
                      "search_session" => $sql
                    },
                }, sub {
                    my ($s, $k, $h, $json) = @_;

                    my $result = $json->{result} // [];

                    # TODO post process result with client aware components

                    say( "Total records: " . @{ $result });
                });
            }
            when(/^json\s({.*})$/) {
                $kernel->yield('get', json_decode($1), sub {
                    my ($s, $k, $h, $json) = @_;

                    my $result = $json->{result} // [];

                    # TODO post process result with client aware components

                    say( "Total records: " . @{ $result });
                });

            }
            when(/^(h|help|\?)/) {
                # check if we want help of a specific command
                if ( ( @action == 2 ) &&
                     ( $action[1] ~~ @{ $commands->{$module_active} } ) ) {
                    $kernel->yield('get', {
                        type => $module_active,
                        data => [ 'help_' . $action[1] ]
                    }, sub {
                        my ($s, $k, $h, $json) = @_;

                        my $result = $json->{result} // '';

                        say( $result );
                    });
                }
                else {
                    say('Commands available:');

                    # list all commands for the current level
                    foreach my $c ( @{ $commands->{$module_active} } ) {
                        say( '  ' . $c );
                    }

                    # list available modules if at root level
                    if ( $module_active eq 'core' ) {
                        foreach my $m ( @{ $modules } ) {
                            next if ( $m eq 'core' );

                            say( '  [' . $m . ']' );
                        }
                    }
                }
            }
            when( /^@{ $commands->{$module_active} }/ ) {
                $kernel->yield('get', {
                    type => $module_active,
                    data => [ @action ],
                }, sub {
                    my ($s, $k, $h, $json) = @_;

                    my $result = $json->{result} // '';

                    # TODO post process result with client aware components
                    say( $result );
                });
            }
            when ( /^@{ $modules }/ ) {
                $module_active = $action[0];

            }
            default {
              say('ERROR: Unknown action: ' . $action[0]);
            }
        }
    }

    prompt_print();
}

sub prompt_print
{
    if ( $module_active eq 'core' ) {
        print('echidna> ');
    }
    else {
        print($module_active . '> ');
    }
}


sub input_get {
    my ( $message ) = @_;

    $message //= '';

    print( 'echidna> ' . $message );

    my $input = <STDIN>;
    chomp($input);

    return $input;
}


sub prompt_process_event_search {
    my ($args) = @_;

    my $sql = {};
    my @search_args = split(/[ ]/, $args);

    foreach my $k ( @search_args ) {
        given( $k ) {
            when(/^--timestamp=([^ ]*)/) {
                $sql->{timestamp} = $1;
            }
            when(/^--classification=([^ ]*)/) {
                $sql->{timestamp} = $1;
            }
            when(/^--node-id=([^ ]*)/) {
                $sql->{node_id} = $1;
            }
            when(/^--src-ip=([^ ]*)/) {
                $sql->{net_src_ip} = $1;
            }
            when(/^--src-port=([^ ]*)/) {
                $sql->{net_src_port} = $1;
            }
            when(/^--dst-ip=([^ ]*)/) {
                $sql->{net_dst_ip} = $1;
            }
            when(/^--dst-port=([^ ]* )/) {
                $sql->{net_dst_port} = $1;
            }
            when(/^--protocol=([^ ]*)/) {
                $sql->{net_protocol} = $1;
            }
            when(/^--version=([^ ]*)/) {
                $sql->{net_version} = $1;
            }
            when(/^--sig-id=([^ ]*)/) {
                $sql->{sig_id} = $1;
            }
            when(/^--sig-revision=([^ ]*)/) {
                $sql->{sig_revision} = $1;
            }
            when(/^--sig-priority=([^ ]*)/) {
                $sql->{sig_priority} = $1;
            }
            when(/^--sig-message=([^ ]*)/) {
                $sql->{sig_message} = $1;
            }
            when(/^--sig-category=([^ ]*)/) {
                $sql->{sig_category} = $1;
            }
            default {
                $logger->debug('Unsupported parameter: ' . $k);
            }
        }
    }

    return $sql;
}


sub prompt_process_session_search {
    my ($args) = @_;

    my $sql = {};
    my @search_args = split(/[ ]/, $args);

    foreach my $k ( @search_args ) {
        given( $k ) {
            when(/^--timestamp=([^ ]*)/) {
                $sql->{timestamp} = $1;
            }
            when(/^--time-start=([^ ]*)/) {
                $sql->{time_start} = $1;
            }
            when(/^--time-end=([^ ]*)/) {
                $sql->{time_end} = $1;
            }
            when(/^--time-duration=([^ ]*)/) {
                $sql->{time_duration} = $1;
            }
            when(/^--node-id=([^ ]*)/) {
                $sql->{node_id} = $1;
            }
            when(/^--src-ip=([^ ]*)/) {
                $sql->{net_src_ip} = $1;
            }
            when(/^--src-port=([^ ]*)/) {
                $sql->{net_src_port} = $1;
            }
            when(/^--src-total-bytes=([^ ]*)/) {
                $sql->{net_src_total_bytes} = $1;
            }
            when(/^--src-total-packets=([^ ]*)/) {
                $sql->{net_src_total_packets} = $1;
            }
            when(/^--src-flagss=([^ ]*)/) {
                $sql->{net_src_flags} = $1;
            }
            when(/^--dst-ip=([^ ]*)/) {
                $sql->{net_dst_ip} = $1;
            }
            when(/^--dst-port=([^ ]* )/) {
                $sql->{net_dst_port} = $1;
            }
            when(/^--dst-total-bytes=([^ ]*)/) {
                $sql->{net_dst_total_bytes} = $1;
            }
            when(/^--dst-total-packets=([^ ]*)/) {
                $sql->{net_dst_total_packets} = $1;
            }
            when(/^--dst-flagss=([^ ]*)/) {
                $sql->{net_dst_flags} = $1;
            }
            when(/^--protocol=([^ ]*)/) {
                $sql->{net_protocol} = $1;
            }
            when(/^--version=([^ ]*)/) {
                $sql->{net_version} = $1;
            }
            default {
                $logger->debug('Unsupported parameter: ' . $k);
            }
        }
    }

    return $sql;
}


POE::Kernel->run();

exit(0);
